use crate::{
    chunk::{Chunk, ChunkData},
    construct::ConstructData,
    player::State,
    Tag, ASTEROID_UPDATE_TIME, CAM_DIMS, CHUNK_DIST, CHUNK_SIZE, FRAME_LOAD_AMOUNT, SAVE_DIR,
    TILE_SIZE, UNLOAD_BIAS,
};
use hex::{
    anyhow,
    assets::Texture,
    components::Transform,
    ecs::{ev::Control, system_manager::System, ComponentManager, EntityManager, Ev, Id, Scene},
    glium::{
        glutin::event::{Event, WindowEvent},
        texture::{MipmapsOption, Texture2d},
        uniforms::{MagnifySamplerFilter, SamplerBehavior},
        Rect,
    },
    math::Vec2d,
    once_cell::sync::OnceCell,
};
use hex_instance::Instance;
use noise::NoiseFn;
use rand::prelude::*;
use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
    rc::Rc,
    time::Instant,
};

pub struct ChunkManager {
    pub player: OnceCell<Option<Id>>,
    pub camera: OnceCell<Option<Id>>,
    pub check: Instant,
    pub frame: Instant,
    pub load_queue: Vec<(u32, u32)>,
    pub loaded: HashMap<(u32, u32), Id>,
}

impl Default for ChunkManager {
    fn default() -> Self {
        Self {
            player: OnceCell::new(),
            camera: OnceCell::new(),
            check: Instant::now(),
            frame: Instant::now(),
            load_queue: Vec::new(),
            loaded: HashMap::new(),
        }
    }
}

impl ChunkManager {
    pub fn gen_chunk(&self, pos: Vec2d, state: &mut State) -> anyhow::Result<ChunkData> {
        let mut data = ChunkData::new(pos);

        for i in 0..data.grid.len() {
            for j in 0..data.grid[i].len() {
                let x = pos.x() as f64 * CHUNK_SIZE as f64 + i as f64;
                let y = pos.y() as f64 * CHUNK_SIZE as f64 + j as f64;
                let val = state.perlin.get([x / 25.0, y / 25.0, 0.0]);
                let ores: Vec<_> = state
                    .ores
                    .values()
                    .filter_map(|t| {
                        t.check(&mut state.rng, val)
                            .map(|(id, t)| (Some(id.clone()), t))
                    })
                    .collect();
                let (id, _) = ores
                    .choose(&mut state.rng)
                    .cloned()
                    .unwrap_or((None, &state.space));

                data.grid[i][j] = id.as_ref().map(|s| s.as_ref().clone());
            }
        }

        Ok(data)
    }

    pub fn chunk_file((x, y): (u32, u32)) -> String {
        format!("{x},{y}.json")
    }

    pub fn load_chunk(
        &mut self,
        chunk @ (x, y): (u32, u32),
        scene: &Scene,
        state: &mut State,
    ) -> anyhow::Result<(Chunk, Instance, Transform)> {
        let chunks_dir = PathBuf::from(SAVE_DIR).join("chunks");
        let path = chunks_dir.join(Self::chunk_file(chunk));
        let data = if Path::exists(&path) {
            let content = fs::read_to_string(path)?;
            let data: ChunkData = serde_json::from_str(content.as_str())?;

            data
        } else {
            let data = self.gen_chunk(Vec2d::new(x as f32, y as f32), state)?;
            let content = serde_json::to_string(&data)?;

            fs::write(path, content)?;

            data
        };
        let texture = Texture {
            buffer: Rc::new(Texture2d::empty_with_mipmaps(
                &scene.display,
                MipmapsOption::AutoGeneratedMipmaps,
                TILE_SIZE * CHUNK_SIZE,
                TILE_SIZE * CHUNK_SIZE,
            )?),
            sampler_behaviour: SamplerBehavior {
                magnify_filter: MagnifySamplerFilter::Nearest,
                ..Default::default()
            },
        };

        let mut chunk = Chunk::new();

        for i in 0..chunk.grid.len() {
            for j in 0..chunk.grid[i].len() {
                let (id, t) = data.grid[i][j]
                    .as_ref()
                    .and_then(|t| state.ores.get(t).map(|t| (Some(t.id.clone()), &t.texture)))
                    .unwrap_or((None, &state.space));
                let data: Vec<_> = t.buffer.read();
                let rect = Rect {
                    left: i as u32 * TILE_SIZE,
                    bottom: j as u32 * TILE_SIZE,
                    width: TILE_SIZE,
                    height: TILE_SIZE,
                };

                texture.buffer.write(rect, data);

                chunk.grid[i][j] = id;
            }
        }

        Ok((
            chunk,
            Instance::new(texture, [1.0; 4], -4.0, true),
            Transform::new(
                Vec2d(data.position) * CHUNK_SIZE as f32,
                0.0,
                Vec2d([CHUNK_SIZE as f32; 2]),
                true,
            ),
        ))
    }

    pub fn chunk_pos(pos: Vec2d) -> (u32, u32) {
        let pos = pos / CHUNK_SIZE as f32;

        (pos.x().ceil() as u32, pos.y().ceil() as u32)
    }

    pub fn load_constructs(
        &mut self,
        player: Id,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) {
        let mut constructs = Vec::new();

        if let Some(state) = cm.get_mut::<State>(player, em) {
            for ConstructData {
                position: position @ (x, y),
                id,
            } in &state.save_data.constructs
            {
                if let Some((construct, instance, sprite)) = state.constructs.get(id).cloned() {
                    let e = em.add();

                    constructs.push((
                        e,
                        (
                            construct,
                            instance,
                            sprite,
                            Transform::new(
                                Vec2d::new(*x as f32, *y as f32) + Vec2d([0.5; 2]),
                                0.0,
                                Vec2d([1.0; 2]),
                                true,
                            ),
                        ),
                    ));

                    state.placed.insert(*position, ((*id).clone(), e));
                }
            }
        }

        for (e, (construct, instance, sprite, transform)) in constructs {
            cm.add(e, construct, em);
            cm.add(e, instance, em);
            cm.add(e, sprite, em);
            cm.add(e, transform, em);
        }
    }
}

impl<'a> System<'a> for ChunkManager {
    fn init(
        &mut self,
        _: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let Some(player) = *self
            .player
            .get_or_init(|| Tag::new("player").find((em, cm)))
        {
            self.load_constructs(player, (em, cm));
        }

        Ok(())
    }

    fn update(
        &mut self,
        ev: &mut Ev,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let (Some(player), Some(camera)) = (
            *self
                .player
                .get_or_init(|| Tag::new("player").find((em, cm))),
            *self
                .camera
                .get_or_init(|| Tag::new("camera").find((em, cm))),
        ) {
            match ev {
                Ev::Event(Control {
                    event: Event::MainEventsCleared,
                    flow: _,
                }) => {
                    let now = Instant::now();
                    let delta = now.duration_since(self.frame);

                    self.frame = now;

                    let chunks: Vec<_> = (0..(FRAME_LOAD_AMOUNT
                        * delta.as_secs_f32().ceil() as u64))
                        .map(|_| self.load_queue.pop())
                        .fuse()
                        .flatten()
                        .collect();

                    for c in chunks {
                        if let Some((chunk, instance, transform)) =
                            if let Some(state) = cm.get_mut::<State>(player, em) {
                                Some(self.load_chunk(c, scene, state)?)
                            } else {
                                None
                            }
                        {
                            let e = em.add();

                            cm.add(e, chunk, em);
                            cm.add(e, instance, em);
                            cm.add(e, transform, em);

                            self.loaded.insert(c, e);
                        }
                    }

                    if now.duration_since(self.check) >= ASTEROID_UPDATE_TIME {
                        self.check = now;

                        if let Some(camera_chunk) = cm
                            .get::<Transform>(camera, em)
                            .and_then(|t| t.active.then_some(Self::chunk_pos(t.position())))
                        {
                            let offset = (CAM_DIMS / CHUNK_SIZE as f32 * CHUNK_DIST).ceil() as u32;
                            let min = (
                                camera_chunk.0.checked_sub(offset).unwrap_or_default(),
                                camera_chunk.1.checked_sub(offset).unwrap_or_default(),
                            );
                            let max = (
                                camera_chunk.0.checked_add(offset).unwrap_or(u32::MAX),
                                camera_chunk.1.checked_add(offset).unwrap_or(u32::MAX),
                            );

                            for i in min.0..max.0 {
                                for j in min.1..max.1 {
                                    let chunk = (i, j);

                                    if !(self.load_queue.contains(&chunk)
                                        || self.loaded.contains_key(&chunk))
                                    {
                                        self.load_queue.push(chunk);
                                    }
                                }
                            }

                            for e in em.entities.clone().into_keys() {
                                if cm.get::<Chunk>(e, em).is_some() {
                                    if let Some(position) =
                                        cm.get::<Transform>(e, em).and_then(|t| {
                                            t.active.then_some(Self::chunk_pos(t.position()))
                                        })
                                    {
                                        if !(position.0
                                            >= min.0.checked_sub(UNLOAD_BIAS).unwrap_or_default()
                                            && position.0
                                                <= max
                                                    .0
                                                    .checked_add(UNLOAD_BIAS)
                                                    .unwrap_or(u32::MAX)
                                            && position.1
                                                >= min
                                                    .1
                                                    .checked_sub(UNLOAD_BIAS)
                                                    .unwrap_or_default()
                                            && position.1
                                                <= max
                                                    .1
                                                    .checked_add(UNLOAD_BIAS)
                                                    .unwrap_or(u32::MAX))
                                        {
                                            self.loaded.remove(&position);

                                            em.rm(e, cm);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Ev::Event(Control {
                    event:
                        Event::WindowEvent {
                            window_id,
                            event: WindowEvent::CloseRequested,
                        },
                    flow: _,
                }) if *window_id == scene.display.gl_window().window().id() => {
                    if let Some((p, state)) = cm
                        .get::<Transform>(player, em)
                        .map(|p| p.position())
                        .and_then(|p| Some((p, cm.get_mut::<State>(player, em)?)))
                    {
                        state.save_data.player_position = p.0;
                        state.save_data.constructs = state
                            .placed
                            .iter()
                            .map(|(pos, (id, _))| ConstructData {
                                position: *pos,
                                id: id.clone(),
                            })
                            .collect();

                        state.save()?;
                    }
                }
                _ => {}
            }
        }

        Ok(())
    }
}
