use super::{chunk::ChunkData, Chunk, Ore, SaveData};
use crate::{
    util, Tag, ASTEROID_UPDATE_TIME, CAM_DIMS, CHUNK_DIST, CHUNK_SIZE, SAVE_DIR, TILE_SIZE,
};
use hex::{
    anyhow,
    assets::Texture,
    components::Transform,
    ecs::{ev::Control, system_manager::System, ComponentManager, EntityManager, Ev, Id, Scene},
    glium::{
        glutin::event::Event,
        texture::{MipmapsOption, Texture2d},
        uniforms::{MagnifySamplerFilter, SamplerBehavior},
        Rect,
    },
    math::Vec2d,
    once_cell::sync::OnceCell,
};
use hex_instance::Instance;
use noise::{NoiseFn, Perlin};
use rand::prelude::*;
use std::{collections::HashSet, fs, path::Path, rc::Rc, time::Instant};

pub struct AsteroidManager {
    pub player: OnceCell<Option<Id>>,
    pub check: Instant,
    pub rng: StdRng,
    pub perlin: Perlin,
    pub ores: Vec<Ore>,
    pub space: Texture,
    pub loaded: HashSet<(u32, u32)>,
    pub save_data: SaveData,
}

impl AsteroidManager {
    pub fn new(scene: &Scene) -> anyhow::Result<Self> {
        let save_path = SAVE_DIR.join("save.json");

        fs::create_dir_all(&*SAVE_DIR)?;

        let save_data = match anyhow::Result::from(fs::read_to_string(&save_path))
            .and_then(|s| Ok(serde_json::from_str(&s)?))
        {
            Ok(data) => data,
            Err(_) => {
                let data = SaveData::default();

                fs::write(&save_path, serde_json::to_string(&data)?)?;

                data
            }
        };
        let mut rng = StdRng::seed_from_u64(save_data.seed);

        Ok(Self {
            player: OnceCell::new(),
            check: Instant::now(),
            perlin: Perlin::new(rng.gen_range(u32::MIN..u32::MAX)),
            rng,
            ores: vec![
                Ore::asteroid_1(&scene.display)?,
                Ore::asteroid_2(&scene.display)?,
                Ore::metal(&scene.display)?,
            ],
            space: util::load_texture(&scene.display, include_bytes!("space.png"))?,
            loaded: HashSet::new(),
            save_data,
        })
    }
}

impl AsteroidManager {
    pub fn gen_chunk(&mut self, pos: Vec2d) -> anyhow::Result<ChunkData> {
        let mut data = ChunkData::new(pos);

        for i in 0..data.grid.len() {
            for j in 0..data.grid[i].len() {
                let x = pos.x() as f64 * CHUNK_SIZE as f64 + i as f64;
                let y = pos.y() as f64 * CHUNK_SIZE as f64 + j as f64;
                let val = self.perlin.get([x / 25.0, y / 25.0, 0.0]);
                let ores: Vec<_> = self
                    .ores
                    .iter()
                    .filter_map(|t| {
                        t.check(&mut self.rng, val)
                            .map(|(id, t)| (Some(id.clone()), t))
                    })
                    .collect();
                let (id, _) = ores
                    .choose(&mut self.rng)
                    .cloned()
                    .unwrap_or((None, &self.space));

                data.grid[i][j] = id.as_ref().map(|s| s.as_ref().clone());
            }
        }

        Ok(data)
    }

    pub fn load_chunk(
        &mut self,
        (x, y): (u32, u32),
        scene: &Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let path = SAVE_DIR.join(format!("{x},{y}.json"));
        let data = if Path::exists(&path) {
            let content = fs::read_to_string(path)?;
            let data: ChunkData = serde_json::from_str(content.as_str())?;

            data
        } else {
            let data = self.gen_chunk(Vec2d::new(x as f32, y as f32))?;

            fs::write(path, &serde_json::to_string(&data)?)?;

            data
        };
        let texture = Texture {
            buffer: Rc::new(Texture2d::empty_with_mipmaps(
                &scene.display,
                MipmapsOption::AutoGeneratedMipmaps,
                TILE_SIZE * CHUNK_SIZE,
                TILE_SIZE * CHUNK_SIZE,
            )?),
            sampler_behaviour: SamplerBehavior {
                magnify_filter: MagnifySamplerFilter::Nearest,
                ..Default::default()
            },
        };

        let mut chunk = Chunk::new(true);

        for i in 0..chunk.grid.len() {
            for j in 0..chunk.grid[i].len() {
                let ores: Vec<_> = self
                    .ores
                    .iter()
                    .filter_map(|t| {
                        data.grid[i][j].as_ref().and_then(|id| {
                            (*id == *t.id).then_some((Some(t.id.clone()), &t.texture))
                        })
                    })
                    .collect();
                let (id, t) = ores
                    .choose(&mut self.rng)
                    .cloned()
                    .unwrap_or((None, &self.space));
                let data: Vec<_> = t.buffer.read();
                let rect = Rect {
                    left: i as u32 * TILE_SIZE,
                    bottom: j as u32 * TILE_SIZE,
                    width: TILE_SIZE,
                    height: TILE_SIZE,
                };

                texture.buffer.write(rect, data);

                chunk.grid[i][j] = id;
            }
        }

        let c = em.add();

        cm.add(c, chunk, em);
        cm.add(c, Instance::new(texture, [1.0; 4], -3.0, true), em);
        cm.add(
            c,
            Transform::new(
                Vec2d(data.position) * CHUNK_SIZE as f32,
                0.0,
                Vec2d([CHUNK_SIZE as f32; 2]),
                true,
            ),
            em,
        );

        Ok(())
    }

    pub fn chunk_pos(pos: Vec2d) -> (u32, u32) {
        let pos = pos / CHUNK_SIZE as f32;

        (pos.x().floor() as u32, pos.y().floor() as u32)
    }
}

impl<'a> System<'a> for AsteroidManager {
    fn update(
        &mut self,
        ev: &mut Ev,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let Ev::Event(Control {
            event: Event::MainEventsCleared,
            flow: _,
        }) = ev
        {
            let now = Instant::now();

            if now.duration_since(self.check) >= ASTEROID_UPDATE_TIME {
                self.check = now;

                if let Some(player_chunk) = self
                    .player
                    .get_or_init(|| Tag::new("player").find((em, cm)))
                    .and_then(|p| {
                        cm.get::<Transform>(p, em)
                            .and_then(|t| t.active.then_some(Self::chunk_pos(t.position())))
                    })
                {
                    let offset = (CAM_DIMS / CHUNK_SIZE as f32).ceil() as u32 * CHUNK_DIST / 2;
                    let min = (
                        player_chunk.0.checked_sub(offset).unwrap_or_default(),
                        player_chunk.1.checked_sub(offset).unwrap_or_default(),
                    );
                    let max = (
                        player_chunk.0.checked_add(offset).unwrap_or(u32::MAX),
                        player_chunk.1.checked_add(offset).unwrap_or(u32::MAX),
                    );

                    for i in min.0..max.0 {
                        for j in min.0..max.0 {
                            let chunk = (i, j);

                            if !self.loaded.contains(&chunk) {
                                self.load_chunk(chunk, scene, (em, cm))?;

                                self.loaded.insert(chunk);
                            }
                        }
                    }

                    for e in em.entities.clone().into_keys() {
                        if cm
                            .get::<Chunk>(e, em)
                            .and_then(|c| c.active.then_some(c))
                            .is_some()
                        {
                            if let Some(position) = cm
                                .get::<Transform>(e, em)
                                .cloned()
                                .and_then(|t| t.active.then_some(Self::chunk_pos(t.position())))
                            {
                                if !(position.0 >= min.0
                                    && position.0 <= max.0
                                    && position.1 >= min.1
                                    && position.1 <= max.1)
                                {
                                    self.loaded.remove(&position);

                                    em.rm(e, cm);
                                }
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
