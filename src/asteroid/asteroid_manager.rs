use super::Asteroid;
use crate::{util, Tag, ASTEROID_UPDATE_TIME, CAM_DIMS, CHUNK_SIZE, MAP_DIMS_X, MAP_DIMS_Y};
use hex::{
    anyhow,
    assets::Texture,
    components::Transform,
    ecs::{ev::Control, system_manager::System, ComponentManager, EntityManager, Ev, Id, Scene},
    glium::{
        glutin::event::Event,
        texture::{MipmapsOption, Texture2d},
        uniforms::{MagnifySamplerFilter, SamplerBehavior},
        Rect,
    },
    math::Vec2d,
    once_cell::sync::OnceCell,
};
use hex_instance::Instance;
use noise::{NoiseFn, Perlin};
use rand::prelude::*;
use std::{rc::Rc, time::Instant};

pub struct AsteroidManager {
    pub asteroids: Vec<Texture>,
    pub space: Texture,
    pub player: OnceCell<Option<Id>>,
    pub check: Instant,
}

impl AsteroidManager {
    pub fn new(scene: &Scene) -> anyhow::Result<Self> {
        Ok(Self {
            asteroids: vec![
                util::load_texture(&scene.display, include_bytes!("asteroid.png"))?,
                util::load_texture(&scene.display, include_bytes!("asteroid2.png"))?,
            ],
            space: util::load_texture(&scene.display, include_bytes!("space.png"))?,
            player: OnceCell::new(),
            check: Instant::now(),
        })
    }

    pub fn spawn_asteroid(
        &mut self,
        pos: Vec2d,
        (x, y): (u32, u32),
        perlin: &Perlin,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let texture = Texture {
            buffer: Rc::new(Texture2d::empty_with_mipmaps(
                &scene.display,
                MipmapsOption::AutoGeneratedMipmaps,
                x * CHUNK_SIZE,
                y * CHUNK_SIZE,
            )?),
            sampler_behaviour: SamplerBehavior {
                magnify_filter: MagnifySamplerFilter::Nearest,
                ..Default::default()
            },
        };

        for i in 0..CHUNK_SIZE {
            for j in 0..CHUNK_SIZE {
                let val = perlin.get([
                    (pos.x() as f64 * CHUNK_SIZE as f64 + i as f64) / 25.0,
                    (pos.y() as f64 * CHUNK_SIZE as f64 + j as f64) / 25.0,
                    0.0,
                ]);
                let rect = Rect {
                    left: i * x,
                    bottom: j * y,
                    width: x,
                    height: y,
                };
                let data = if let Some(asteroid) = self
                    .asteroids
                    .choose(&mut thread_rng())
                    .and_then(|a| (val > 0.0).then_some(a))
                {
                    let data: Vec<_> = asteroid.buffer.read();

                    data
                } else {
                    let data: Vec<_> = self.space.buffer.read();

                    data
                };

                texture.buffer.write(rect, data);
            }
        }

        let asteroid = em.add();

        cm.add(asteroid, Instance::new(texture, [1.0; 4], -3.0, true), em);
        cm.add(
            asteroid,
            Transform::new(
                Vec2d::new(pos.x() * x as f32, pos.y() * y as f32),
                0.0,
                Vec2d::new(x as f32, y as f32),
                true,
            ),
            em,
        );
        cm.add(asteroid, Asteroid::new(true), em);

        Ok(())
    }

    pub fn spawn_map(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let (x, y) = self.space.buffer.dimensions();
        let perlin = Perlin::new(thread_rng().gen_range(u32::MIN..u32::MAX));

        for i in 0..(MAP_DIMS_X / CHUNK_SIZE) {
            for j in 0..(MAP_DIMS_Y / CHUNK_SIZE) {
                self.spawn_asteroid(
                    Vec2d::new(i as f32, j as f32),
                    (x, y),
                    &perlin,
                    scene,
                    (em, cm),
                )?;
            }
        }

        Ok(())
    }
}

impl<'a> System<'a> for AsteroidManager {
    fn init(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        self.spawn_map(scene, (em, cm))?;

        Ok(())
    }

    fn update(
        &mut self,
        ev: &mut Ev,
        _: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let Ev::Event(Control {
            event: Event::MainEventsCleared,
            flow: _,
        }) = ev
        {
            let now = Instant::now();

            if now.duration_since(self.check) >= ASTEROID_UPDATE_TIME {
                self.check = now;

                if let Some(player_pos) = self
                    .player
                    .get_or_init(|| Tag::new("player").find((em, cm)))
                    .and_then(|p| {
                        cm.get::<Transform>(p, em)
                            .and_then(|t| t.active.then_some(t.position()))
                    })
                {
                    for e in em.entities.keys().cloned() {
                        if cm
                            .get::<Asteroid>(e, em)
                            .and_then(|a| a.active.then_some(a))
                            .is_some()
                        {
                            if let Some((position, instance)) =
                                cm.get::<Transform>(e, em).cloned().and_then(|t| {
                                    Some((
                                        t.active.then_some(t.position())?,
                                        cm.get_mut::<Instance>(e, em)?,
                                    ))
                                })
                            {
                                instance.active = (position - player_pos).magnitude()
                                    < (CAM_DIMS.powi(2) * 2.0).sqrt();
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
