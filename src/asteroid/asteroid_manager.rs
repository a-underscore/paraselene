use super::{Asteroid, Chunk, Ore};
use crate::{
    util, Tag, ASTEROID_UPDATE_TIME, CAM_DIMS, CHUNK_SIZE, MAP_DIMS_X, MAP_DIMS_Y, TILE_SIZE,
};
use hex::{
    anyhow,
    assets::Texture,
    components::Transform,
    ecs::{ev::Control, system_manager::System, ComponentManager, EntityManager, Ev, Id, Scene},
    glium::{
        glutin::event::Event,
        texture::{MipmapsOption, Texture2d},
        uniforms::{MagnifySamplerFilter, SamplerBehavior},
        Rect,
    },
    math::Vec2d,
    once_cell::sync::OnceCell,
};
use hex_instance::Instance;
use noise::{NoiseFn, Perlin};
use rand::prelude::*;
use std::{rc::Rc, time::Instant};

pub struct AsteroidManager {
    pub player: OnceCell<Option<Id>>,
    pub check: Instant,
    pub rng: StdRng,
}

impl Default for AsteroidManager {
    fn default() -> Self {
        Self {
            player: OnceCell::new(),
            check: Instant::now(),
            rng: StdRng::seed_from_u64(1),
        }
    }
}

impl AsteroidManager {
    pub fn spawn_chunk(
        &mut self,
        pos: Vec2d,
        ores: &[Ore],
        space: &Texture,
        perlin: &Perlin,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let texture = Texture {
            buffer: Rc::new(Texture2d::empty_with_mipmaps(
                &scene.display,
                MipmapsOption::AutoGeneratedMipmaps,
                TILE_SIZE * CHUNK_SIZE,
                TILE_SIZE * CHUNK_SIZE,
            )?),
            sampler_behaviour: SamplerBehavior {
                magnify_filter: MagnifySamplerFilter::Nearest,
                ..Default::default()
            },
        };

        for i in 0..CHUNK_SIZE {
            for j in 0..CHUNK_SIZE {
                let x = pos.x() as f64 * CHUNK_SIZE as f64 + i as f64;
                let y = pos.y() as f64 * CHUNK_SIZE as f64 + j as f64;
                let val = perlin.get([x / 25.0, y / 25.0, 0.0]);
                let ores: Vec<_> = ores
                    .iter()
                    .filter_map(|t| t.check(&mut self.rng, val))
                    .collect();
                let (id, t) = ores
                    .choose(&mut self.rng)
                    .cloned()
                    .map(|(id, t)| (Some(id), t))
                    .unwrap_or((None, space));
                let data: Vec<_> = t.buffer.read();
                let rect = Rect {
                    left: i * TILE_SIZE,
                    bottom: j * TILE_SIZE,
                    width: TILE_SIZE,
                    height: TILE_SIZE,
                };

                texture.buffer.write(rect, data);

                if let Some(id) = id {
                    let asteroid = em.add();

                    cm.add(asteroid, Asteroid::new(id.clone(), true), em);
                    cm.add(
                        asteroid,
                        Transform::new(
                            Vec2d::new(
                                x as f32 - (CHUNK_SIZE / 2) as f32 + 0.5,
                                y as f32 - (CHUNK_SIZE / 2) as f32 + 0.5,
                            ),
                            0.0,
                            Vec2d([1.0; 2]),
                            true,
                        ),
                        em,
                    );
                }
            }
        }

        let chunk = em.add();

        cm.add(chunk, Chunk::new(true), em);
        cm.add(chunk, Instance::new(texture, [1.0; 4], -3.0, true), em);
        cm.add(
            chunk,
            Transform::new(
                pos * CHUNK_SIZE as f32,
                0.0,
                Vec2d([CHUNK_SIZE as f32; 2]),
                true,
            ),
            em,
        );

        Ok(())
    }

    pub fn spawn_map(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let ores = vec![Ore::rock(&scene.display)?, Ore::metal(&scene.display)?];
        let space = util::load_texture(&scene.display, include_bytes!("space.png"))?;
        let perlin = Perlin::new(self.rng.gen_range(u32::MIN..u32::MAX));

        for i in 0..(MAP_DIMS_X / CHUNK_SIZE) {
            for j in 0..(MAP_DIMS_Y / CHUNK_SIZE) {
                self.spawn_chunk(
                    Vec2d::new(i as f32, j as f32),
                    &ores,
                    &space,
                    &perlin,
                    scene,
                    (em, cm),
                )?;
            }
        }

        Ok(())
    }
}

impl<'a> System<'a> for AsteroidManager {
    fn init(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        self.spawn_map(scene, (em, cm))?;

        Ok(())
    }

    fn update(
        &mut self,
        ev: &mut Ev,
        _: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let Ev::Event(Control {
            event: Event::MainEventsCleared,
            flow: _,
        }) = ev
        {
            let now = Instant::now();

            if now.duration_since(self.check) >= ASTEROID_UPDATE_TIME {
                self.check = now;

                if let Some(player_pos) = self
                    .player
                    .get_or_init(|| Tag::new("player").find((em, cm)))
                    .and_then(|p| {
                        cm.get::<Transform>(p, em)
                            .and_then(|t| t.active.then_some(t.position()))
                    })
                {
                    for e in em.entities.keys().cloned() {
                        if cm
                            .get::<Asteroid>(e, em)
                            .and_then(|a| a.active.then_some(a))
                            .is_some()
                            || cm
                                .get::<Chunk>(e, em)
                                .and_then(|c| c.active.then_some(c))
                                .is_some()
                        {
                            if let Some((position, instance)) =
                                cm.get::<Transform>(e, em).cloned().and_then(|t| {
                                    Some((
                                        t.active.then_some(t.position())?,
                                        cm.get_mut::<Instance>(e, em)?,
                                    ))
                                })
                            {
                                instance.active = (position - player_pos).magnitude()
                                    < (CAM_DIMS.powi(2) * 2.0).sqrt()
                                        + (((CHUNK_SIZE as f32) / 2.0).powi(2) * 2.0).sqrt();
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
