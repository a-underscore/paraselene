use super::{chunk::ChunkData, Asteroid, Chunk, Ore};
use crate::{
    util, Tag, ASTEROID_UPDATE_TIME, CAM_DIMS, CHUNK_DIST, CHUNK_SIZE, MAP_DIMS_X, MAP_DIMS_Y,
    TILE_SIZE,
};
use hex::{
    anyhow,
    assets::Texture,
    components::Transform,
    ecs::{ev::Control, system_manager::System, ComponentManager, EntityManager, Ev, Id, Scene},
    glium::{
        glutin::event::Event,
        texture::{MipmapsOption, Texture2d},
        uniforms::{MagnifySamplerFilter, SamplerBehavior},
        Rect,
    },
    math::Vec2d,
    once_cell::sync::OnceCell,
};
use hex_instance::Instance;
use noise::{NoiseFn, Perlin};
use rand::prelude::*;
use std::{
    collections::HashSet,
    fs,
    io::{Read, Write},
    rc::Rc,
    time::Instant,
};

pub struct AsteroidManager {
    pub player: OnceCell<Option<Id>>,
    pub check: Instant,
    pub rng: StdRng,
    pub ores: Vec<Ore>,
    pub loaded: HashSet<(u32, u32)>,
}

impl AsteroidManager {
    pub fn new(scene: &Scene) -> anyhow::Result<Self> {
        Ok(Self {
            player: OnceCell::new(),
            check: Instant::now(),
            rng: StdRng::seed_from_u64(0),
            ores: vec![
                Ore::asteroid_1(&scene.display)?,
                Ore::asteroid_2(&scene.display)?,
                Ore::metal(&scene.display)?,
            ],
            loaded: HashSet::new(),
        })
    }
}

impl AsteroidManager {
    pub fn spawn_chunk(
        &mut self,
        pos: Vec2d,
        space: &Texture,
        perlin: &Perlin,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let texture = Texture {
            buffer: Rc::new(Texture2d::empty_with_mipmaps(
                &scene.display,
                MipmapsOption::AutoGeneratedMipmaps,
                TILE_SIZE * CHUNK_SIZE,
                TILE_SIZE * CHUNK_SIZE,
            )?),
            sampler_behaviour: SamplerBehavior {
                magnify_filter: MagnifySamplerFilter::Nearest,
                ..Default::default()
            },
        };
        let mut chunk = Chunk::new(true);

        for i in 0..CHUNK_SIZE {
            for j in 0..CHUNK_SIZE {
                let x = pos.x() as f64 * CHUNK_SIZE as f64 + i as f64;
                let y = pos.y() as f64 * CHUNK_SIZE as f64 + j as f64;
                let val = perlin.get([x / 25.0, y / 25.0, 0.0]);
                let ores: Vec<_> = self
                    .ores
                    .iter()
                    .filter_map(|t| t.check(&mut self.rng, val))
                    .collect();
                let (id, t) = ores
                    .choose(&mut self.rng)
                    .cloned()
                    .map(|(id, t)| (Some(id.clone()), t))
                    .unwrap_or((None, space));
                let data: Vec<_> = t.buffer.read();
                let rect = Rect {
                    left: i * TILE_SIZE,
                    bottom: j * TILE_SIZE,
                    width: TILE_SIZE,
                    height: TILE_SIZE,
                };

                texture.buffer.write(rect, data);

                chunk.grid[i as usize][j as usize] = id;
            }
        }

        let c = em.add();

        cm.add(c, chunk, em);
        cm.add(c, Instance::new(texture, [1.0; 4], -3.0, true), em);
        cm.add(
            c,
            Transform::new(
                pos * CHUNK_SIZE as f32,
                0.0,
                Vec2d([CHUNK_SIZE as f32; 2]),
                true,
            ),
            em,
        );

        Ok(())
    }

    pub fn load_chunks(
        &mut self,
        (x, y): (u32, u32),
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let content = fs::read_to_string(format!("[{x}][{y}].json"))?;
        let data: ChunkData = serde_json::from_str(content.as_str())?;

        Ok(())
    }

    pub fn spawn_map(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        let space = util::load_texture(&scene.display, include_bytes!("space.png"))?;
        let perlin = Perlin::new(self.rng.gen_range(u32::MIN..u32::MAX));

        for i in 0..(MAP_DIMS_X / CHUNK_SIZE) {
            for j in 0..(MAP_DIMS_Y / CHUNK_SIZE) {
                self.spawn_chunk(
                    Vec2d::new(i as f32, j as f32),
                    &space,
                    &perlin,
                    scene,
                    (em, cm),
                )?;
            }
        }

        Ok(())
    }

    pub fn chunk_pos(pos: Vec2d) -> (u32, u32) {
        let pos = pos / CHUNK_SIZE as f32;

        (pos.x().floor() as u32, pos.y().floor() as u32)
    }
}

impl<'a> System<'a> for AsteroidManager {
    fn init(
        &mut self,
        scene: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        self.spawn_map(scene, (em, cm))?;

        Ok(())
    }

    fn update(
        &mut self,
        ev: &mut Ev,
        _: &mut Scene,
        (em, cm): (&mut EntityManager, &mut ComponentManager),
    ) -> anyhow::Result<()> {
        if let Ev::Event(Control {
            event: Event::MainEventsCleared,
            flow: _,
        }) = ev
        {
            let now = Instant::now();

            if now.duration_since(self.check) >= ASTEROID_UPDATE_TIME {
                self.check = now;

                if let Some(player_chunk) = self
                    .player
                    .get_or_init(|| Tag::new("player").find((em, cm)))
                    .and_then(|p| {
                        cm.get::<Transform>(p, em)
                            .and_then(|t| t.active.then_some(Self::chunk_pos(t.position())))
                    })
                {
                    for e in em.entities.keys().cloned() {
                        if cm
                            .get::<Asteroid>(e, em)
                            .and_then(|a| a.active.then_some(a))
                            .is_some()
                            || cm
                                .get::<Chunk>(e, em)
                                .and_then(|c| c.active.then_some(c))
                                .is_some()
                        {
                            if let Some((position, instance)) =
                                cm.get::<Transform>(e, em).cloned().and_then(|t| {
                                    Some((
                                        t.active.then_some(Self::chunk_pos(t.position()))?,
                                        cm.get_mut::<Instance>(e, em)?,
                                    ))
                                })
                            {
                                let offset =
                                    (CAM_DIMS / CHUNK_SIZE as f32).ceil() as u32 * CHUNK_DIST / 2;
                                let min = (
                                    player_chunk.0.checked_sub(offset).unwrap_or_default(),
                                    player_chunk.1.checked_sub(offset).unwrap_or_default(),
                                );
                                let max = (
                                    player_chunk.0.checked_add(offset).unwrap_or(u32::MAX),
                                    player_chunk.1.checked_add(offset).unwrap_or(u32::MAX),
                                );

                                instance.active = position.0 >= min.0
                                    && position.0 <= max.0
                                    && position.1 >= min.1
                                    && position.1 <= max.1;
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
